# 四元数 (Quaternion) 知识

四元数（Quaternion）是一种在计算机图形学、机器人学、航空航天等领域广泛用于表示三维空间旋转的数学工具。它由四个分量组成，通常写成 $q = w + xi + yj + zk$，其中 $w$ 是实部，$(x, y, z)$ 是虚部，而 $i, j, k$ 是满足特定乘法规则的虚数单位。

## 为什么使用四元数？

在理解四元数之前，我们先看看其他表示旋转的方法及其局限性：

### 1. 欧拉角 (Euler Angles)

*   **优点:** 直观，容易理解（例如：绕 X 轴旋转俯仰角、绕 Y 轴旋转滚转角、绕 Z 轴旋转偏航角）。
*   **缺点:**
    *   **万向锁 (Gimbal Lock):** 当两个旋转轴对齐时，会丢失一个自由度，导致无法通过改变其中一个角度来达到预期的旋转，或者有多种欧拉角组合表示同一旋转。
    *   **顺序依赖:** 旋转的最终结果取决于旋转轴的顺序（例如 X-Y-Z 和 Z-Y-X 顺序得到的结果不同）。
    *   **插值困难:** 在两个旋转之间进行平滑插值（例如动画）时，容易出现不自然的旋转路径。

### 2. 旋转矩阵 (Rotation Matrices)

*   **优点:** 易于对点和向量进行变换（矩阵乘法），可以方便地串联多个旋转（矩阵乘法）。
*   **缺点:**
    *   **冗余:** 用 9 个数字（3x3 矩阵）来表示 3 个自由度的旋转，效率较低。
    *   **数值误差:** 在多次乘法或浮点运算后，可能会积累误差导致矩阵不再是正交矩阵，需要定期进行“正交化”处理，这会带来额外的计算成本。
    *   **插值困难:** 对矩阵进行插值不像欧拉角那样简单。

### 四元数的优势:

*   **无万向锁:** 根本上避免了万向锁问题，能够表示任何三维旋转。
*   **紧凑:** 用 4 个数字表示旋转，比旋转矩阵更紧凑。
*   **高效:** 串联多个旋转（四元数乘法）比矩阵乘法计算量更小。
*   **平滑插值:** 提供了球形线性插值 (SLERP) 等方法，可以实现非常平滑和自然的旋转动画。
*   **数值稳定性:** 相比旋转矩阵，在浮点运算中更不容易积累误差。

## 四元数的基本概念

一个四元数 $q$ 可以表示为：
$$q = w + xi + yj + zk$$
或更常见的表示为：
$$q = (w, \vec{v})$$
其中 $w$ 是**实部**（或标量部分），$\vec{v} = (x, y, z)$ 是一个三维向量（**虚部**）。

### 核心思想：轴-角表示法的映射

最直观的理解方式是将四元数与**轴-角 (Axis-Angle)** 表示法联系起来。任何三维空间中的旋转都可以唯一地表示为：

1.  **一个旋转轴**：一个单位向量 $\hat{n} = (n_x, n_y, n_z)$。
2.  **一个旋转角度**：一个角度 $\theta$（通常在 $0$ 到 $2\pi$ 之间）。

四元数就是将这个“旋转轴”和“旋转角度”编码进其四个分量 $w, x, y, z$ 中。

如果一个物体绕着单位向量轴 $\hat{n} = (n_x, n_y, n_z)$ 旋转了角度 $\theta$，那么对应的单位四元数 $q = (w, x, y, z)$ 的分量计算如下：

$$w = \cos(\theta / 2)$$
$$x = n_x \sin(\theta / 2)$$
$$y = n_y \sin(\theta / 2)$$
$$z = n_z \sin(\theta / 2)$$

### 四个分量的含义

*   **$w$ 分量（实部）**：
    *   主要与**旋转角度**有关。它表示旋转的“程度”或“幅度”。
    *   当 $w=1$ 时，表示 $\theta=0$，即没有旋转，四元数是 $(1, 0, 0, 0)$，是恒等四元数。
    *   当 $w=0$ 时，表示 $\theta=\pi$ (180度) 旋转。
    *   它的值介于 $-1$ 到 $1$ 之间。

*   **$(x, y, z)$ 分量（虚部，向量部分）**：
    *   主要与**旋转轴**有关。这个向量 $(x, y, z)$ 的方向就是旋转轴 $\hat{n}$ 的方向。
    *   这个向量的**模长** $||(x, y, z)|| = \sin(\theta / 2)$，与旋转角度的**一半的正弦值**成正比。这意味着旋转角度越大（接近 $180^\circ$），这个向量的模长就越大。
    *   如果 $\theta=0$，则 $\sin(\theta/2)=0$，所以 $(x, y, z) = (0, 0, 0)$。
    *   如果 $\theta=\pi$，则 $\sin(\theta/2)=1$，所以 $(x, y, z) = \hat{n}$。

### 1. 单位四元数 (Unit Quaternion)

*   只有**单位四元数**（模长为 1 的四元数，即 $||q|| = \sqrt{w^2 + x^2 + y^2 + z^2} = 1$）才能表示旋转。
*   非单位四元数除了表示旋转，还会引起缩放。在实际应用中，我们总是使用单位四元数来表示旋转，并定期对其进行归一化以消除浮点误差。

### 2. 恒等四元数 (Identity Quaternion)

*   $$q_{identity} = (1, 0, 0, 0)$$
*   表示**不进行任何旋转**。

### 3. 共轭四元数 (Conjugate)

*   如果 $q = (w, x, y, z)$，则其共轭为 $q^* = (w, -x, -y, -z)$。
*   在四元数运算中非常有用，尤其是计算逆。

### 4. 逆四元数 (Inverse)

*   $$q^{-1} = q^* / ||q||^2$$
*   对于**单位四元数**，由于 $||q||^2 = 1$，所以其逆就是其共轭：$q^{-1} = q^*$。
*   逆四元数表示与原四元数**方向相反的旋转**。

### 5. 归一化 (Normalization)

*   $$q_{normalized} = q / ||q||$$
*   将任意四元数转换为单位四元数。这是非常重要的步骤，用于在多次旋转后校正累积的浮点误差。

##  四元数乘法 (Quaternion Multiplication / Hamilton Product)

四元数相乘遵循的是**汉密尔顿积 (Hamilton Product)** 原则。这是四元数运算中最核心且最复杂的概念之一。理解其原理对于正确使用四元数表示和组合旋转至关重要。

### 1. 汉密尔顿积 (Hamilton Product)

给定两个四元数：
$q_1 = w_1 + x_1i + y_1j + z_1k = (w_1, \vec{v_1})$
$q_2 = w_2 + x_2i + y_2j + z_2k = (w_2, \vec{v_2})$

它们的乘积 $q_{res} = q_1 q_2$ 的结果是一个新的四元数，其计算公式为：

$$q_{res} = (w_1w_2 - \vec{v_1} \cdot \vec{v_2}) + (w_1\vec{v_2} + w_2\vec{v_1} + \vec{v_1} \times \vec{v_2})$$

展开为分量形式，则有：

$$w_{res} = w_1w_2 - x_1x_2 - y_1y_2 - z_1z_2$$
$$x_{res} = w_1x_2 + x_1w_2 + y_1z_2 - z_1y_2$$
$$y_{res} = w_1y_2 - x_1z_2 + y_1w_2 + z_1x_2$$
$$z_{res} = w_1z_2 + x_1y_2 - y_1x_2 + z_1w_2$$

这里的关键是虚数单位 $i, j, k$ 之间的乘法规则：

*   $i^2 = j^2 = k^2 = ijk = -1$
*   $ij = k$, $ji = -k$
*   $jk = i$, $kj = -i$
*   $ki = j$, $ik = -j$

这些规则与向量的叉乘和点乘非常相似，这也是上述公式中出现点乘和叉乘项的原因。

### 2. 非交换律 (Non-Commutativity)

四元数乘法**不满足交换律**，即：

$$q_1 q_2 \neq q_2 q_1$$

除非两个四元数是平行（或反平行）的，或者其中一个是恒等四元数。

这与三维空间中的旋转特性是一致的：先绕 X 轴旋转 90 度再绕 Y 轴旋转 90 度，与先绕 Y 轴旋转 90 度再绕 X 轴旋转 90 度，得到的最终姿态是不同的。

### 3. 几何解释：旋转的组合

四元数乘法最直观的几何意义是**组合连续的旋转**。

*   **右乘 ($q_{new} = q_{current} \cdot q_{delta}$):**
    这种乘法顺序表示将 $q_{delta}$ 所代表的旋转应用到由 $q_{current}$ 定义的**当前（本地）坐标系**中。
    例如，如果 `current_orientation` 是一个物体的当前姿态（相对于世界坐标系），而 `delta_rotation` 是物体在自身坐标系中发生的微小旋转，那么 `new_orientation = current_orientation * delta_rotation` 会得到物体在世界坐标系中的新姿态，也即将`delta_rotation`基于的轴转为`current_orientation`当前坐标系的轴再进行旋转。这是物理引擎中姿态更新的常见方式，因为物体的角速度通常是在其自身坐标系中测量的。

*   **左乘 ($q_{new} = q_{delta} \cdot q_{current}$):**
    这种乘法顺序表示将 $q_{delta}$ 所代表的旋转应用到**世界（全局）坐标系**中。
    例如，如果你有一个物体在世界坐标系中的姿态 `current_orientation`，你想让它绕世界坐标系的某个轴旋转一个 `delta_rotation`，那么你可以使用 `new_orientation = delta_rotation * current_orientation`。

*   **左乘与右乘**：对$q_a \cdot q_b$这样一种情况，既可以理解为先在世界坐标系中旋转$q_a$然后在$q_a$本体坐标系旋转$q_b$，也可以理解成先在世界坐标系下旋转$q_b$然后在世界坐标系下再施加旋转$q_a$

### 4. 旋转向量/点

当使用四元数 $q$ 来旋转一个三维向量 $\vec{p}$（或点）时，需要将其转换为一个纯虚四元数 $P = (0, \vec{p})$，然后进行“三明治”乘法：

$$P' = q \cdot P \cdot q^{-1}$$

如果 $q$ 是单位四元数（通常情况下），那么 $q^{-1} = q^*$，因此：

$$P' = q \cdot P \cdot q^*$$

这里 $P'$ 也是一个纯虚四元数，其虚部就是旋转后的向量 $\vec{p}'$。

### 总结

四元数相乘遵循汉密尔顿积原则，这是一个非交换的数学运算，其几何意义是组合连续的旋转。乘法顺序决定了旋转是在本地坐标系中应用还是在全局坐标系中应用。这种特性使其成为在三维空间中高效、稳定地处理旋转的强大工具。

## 如何表示旋转 (轴-角表示)

四元数最直观的几何解释是它与**轴-角 (Axis-Angle)** 表示法的直接对应关系。

如果一个物体绕着单位向量轴 $\hat{n} = (n_x, n_y, n_z)$ 旋转了角度 $\theta$，那么对应的单位四元数是：

$$w = \cos(\theta / 2)$$
$$x = n_x \sin(\theta / 2)$$
$$y = n_y \sin(\theta / 2)$$
$$z = n_z \sin(\theta / 2)$$

## 如何用四元数旋转一个点/向量

要将一个三维向量 $\vec{P} = (p_x, p_y, p_z)$ 旋转，首先将其表示为一个纯虚四元数 $P = (0, p_x, p_y, p_z)$。
如果旋转由单位四元数 $q$ 表示，那么旋转后的向量 $P'$ 对应的纯虚四元数是：

$$P' = q \cdot P \cdot q^{-1}$$
对于单位四元数，由于 $q^{-1} = q^*$，则：
$$P' = q \cdot P \cdot q^*$$

## 四元数在 AirSim 中的应用

在 `FastPhysicsEngine` 中，四元数被用于表示无人机的姿态 (`Kinematics::State::pose::orientation`)，并通过以下步骤进行更新：

1.  **计算平均角速度 (`avg_angular`):** 这是在当前时间步内物体在**机体坐标系**下的平均旋转速度向量。

2.  **计算微小旋转的轴-角:**
    *   旋转轴就是 `avg_angular` 的单位向量。
    *   旋转角度是 `avg_angular` 的模长乘以时间步长 `dt`。
    *   对应的 `AngleAxisr` 构造函数：`AngleAxisr(angle_per_unit * dt_real, avg_angular / angle_per_unit)`。

3.  **将轴-角转换为四元数 (`angle_dt_q`):** 这个四元数表示物体在当前时间步内相对于其自身的微小旋转。

4.  **应用旋转:**
    ```cpp
    next.pose.orientation = current_pose.orientation * angle_dt_q;
    ```
    *   `current_pose.orientation` 是无人机当前的全局姿态。
    *   `angle_dt_q` 是在无人机**本地坐标系**中发生的微小旋转。
    *   四元数乘法自然地将这个本地旋转叠加到全局姿态上，得到新的全局姿态 `next.pose.orientation`。

5.  **归一化:**
    ```cpp
    next.pose.orientation.normalize();
    ```
    每次更新后都进行归一化，以防止数值误差累积。

这种方法确保了姿态更新的平滑性、准确性，并且避免了欧拉角可能导致的万向锁问题，这对于模拟无人机这种需要高精度姿态控制的载具至关重要。